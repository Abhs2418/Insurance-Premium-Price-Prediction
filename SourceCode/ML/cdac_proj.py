# -*- coding: utf-8 -*-
"""CDAC_Proj.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YTJHOsAh9n0nxVIjBjQTiWOFZocKxofN
"""

import pandas as pd
import numpy as np
import seaborn as sns
import statsmodels.api as sm
import matplotlib.pyplot as plt
from statsmodels.stats.outliers_influence import variance_inflation_factor
from sklearn.preprocessing import power_transform,RobustScaler,PowerTransformer,FunctionTransformer
from sklearn.pipeline import Pipeline
from sklearn import datasets
from keras import models
from keras import layers
from keras import optimizers
from sklearn.preprocessing import PowerTransformer
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import RobustScaler,MinMaxScaler,StandardScaler
import pickle

df=pd.read_csv("/content/part-00000-9eb8133c-407f-47c6-918f-905dc2d5fbea-c000.csv")
df.head()

features=['Occupation_Index','Previous_Claims','Year','Smoking_Status_Index','Location_Index']
target_col='Premium_Amount'

plt.hist(df['Annual_Income'])

plt.hist(df['Premium_Amount'])

scaler = StandardScaler()
Annual_scaled=scaler.fit_transform(pd.DataFrame(df["Annual_Income"],columns=["Annual_Income"]))
plt.hist(np.cos(Annual_scaled))

Annual_Income_Scaled=np.cos(np.log(df["Annual_Income"]))
#Annual_Income_Scaled = np.where(Annual_Income_Scaled< 20000,
#                           np.cbrt(Annual_Income_Scaled),
#                           np.sqrt(Annual_Income_Scaled))
plt.hist(Annual_Income_Scaled)

income_scaler = MinMaxScaler(feature_range=(1, 5000))


income_scaled = income_scaler.fit_transform(pd.DataFrame(df["Annual_Income"]))
plt.scatter(income_scaled-5000,df["Premium_Amount"])

numbers = np.array([1, 8, 27, 64])
cube_roots = np.cbrt(numbers)
cube_roots

# Initialize scalers
income_scaler = MinMaxScaler(feature_range=(1, 5000))

# Transform income to premium range (1-5000)
income_scaled = income_scaler.fit_transform(pd.DataFrame(df["Annual_Income"]))

# Calculate weighted premium based on scaled income
# This ensures higher income leads to higher premium
alpha = 0.7  # Weight factor for income influence
beta = 0.3   # Weight factor for random variation

# Add small random variation to avoid perfect correlation
random_factor = np.random.uniform(0.95, 1.05, size=income_scaled.shape)

# Combine scaled income with random variation
transformed_premium = (alpha * income_scaled +
                         beta * income_scaled * random_factor)

# Ensure transformed premium stays within original range
premium_scaler = MinMaxScaler(feature_range=(1, 5000))
transformed_premium = premium_scaler.fit_transform(transformed_premium)


transformed_premium
# Calculate correlation coefficient
correlation = np.corrcoef(income_scaled.flatten(),
                           transformed_premium.flatten())[0,1]
correlation

np.corrcoef(df['Premium_Amount'],df["Previous_Claims"])[0,1]

sample=df[df['Annual_Income'] <100]
plt.scatter(y=sample['Premium_Amount'],x=sample['Annual_Income'])

for col in df.columns:
    if col!=target_col:
      print(col," ",np.corrcoef(df['Premium_Amount'],df[col])[0,1])

for col in df.columns:
    if col!=target_col:
      plt.scatter(y=df[target_col],x=df[col])
      plt.title(f'{col} vs {target_col}')
      plt.xlabel(col)
      plt.ylabel(target_col)
      plt.show()
      plt.savefig(f"{col} vs {target_col}.png")

df_copy=df.copy()

import pandas as pd

# def scale_premium_for_row(row):
#   premium = row['Premium_Amount']
#   if 0 <= premium <= 1000:
#     base_income = (premium / 1000) * 40000
#   elif 1000 < premium <= 2000:
#     base_income = 40000 + ((premium - 1000) / 1000) * 30000
#   elif 2000 < premium <= 3000:
#     base_income = 70000 + ((premium - 2000) / 1000) * 40000
#   elif 3000 < premium <= 4000:
#     base_income = 110000 + ((premium - 3000) / 1000) * 30000
#   else: # Premium between 4000 and 5000
#     base_income = 140000 + ((premium - 4000) / 1000) * 10000
#   noise=0
#   if np.random.rand() < 0.005 and base_income<100000:
#     noise = np.random.uniform(-40000,40000)
#   return abs(base_income + noise)
def scale_premium_for_row(row):
  """
  Scales the Annual Income
  """
  premium = row['Premium_Amount']
  if 0 <= premium <= 1000:
    base_income = 140000 - ((premium / 1000) * 40000)
  elif 1000 < premium <= 2000:
    base_income = 110000 - (((premium - 1000) / 1000) * 30000)
  elif 2000 < premium <= 3000:
    base_income = 70000 - (((premium - 2000) / 1000) * 40000)
  elif 3000 < premium <= 4000:
    base_income = 40000 - (((premium - 3000) / 1000) * 30000)
  else: # Premium between 4000 and 5000
    base_income = 10000 - (((premium - 4000) / 1000) * 10000)
  noise=0
  if np.random.rand() < 0.005 and base_income<100000:
    noise = np.random.uniform(-40000,40000)
  return abs(base_income + noise)
df_copy['Annual_Income'] = df_copy.apply(scale_premium_for_row, axis=1)

plt.scatter(df_copy[target_col],df_copy["Annual_Income"])

features

min(df_copy['Previous_Claims']),max(df_copy['Previous_Claims'])

max(df_copy["Premium_Amount"])

import pandas as pd
import numpy as np
def get_num_claims(row):
    """
    Determines a random number of claims based on the insurance amount.
    """
    insurance_amount = row['Premium_Amount']
    claims=0
    if 0 <= insurance_amount < 1000:  #Based on range used in the original code
      claims=np.random.randint(0, 3)  # Returns a random integer between 0 (inclusive) and 3 (exclusive).
    elif 1000 <= insurance_amount < 2000: #Based on range used in the original code
      claims=np.random.randint(3, 6) # Returns a random integer between 3 (inclusive) and 6 (exclusive).
    elif 2000 <= insurance_amount < 3000: #Based on range used in the original code
      claims=np.random.randint(5, 7)  # Returns a random integer between 5 (inclusive) and 7 (exclusive).
    elif 3000 <= insurance_amount <= 5400: #Based on range used in the original code
      claims=np.random.randint(7, 9) # Returns a random integer between 7 (inclusive) and 9 (exclusive).
    noise=0
    if np.random.rand() < 0.005:
      noise = np.random.uniform(-1,1)
    return int(claims+noise/8)

df_copy['Previous_Claims'] = df_copy.apply(get_num_claims, axis=1)

plt.scatter(df_copy[target_col],df_copy["Previous_Claims"])
plt.xlabel("Premium Amount")
plt.ylabel("Number of Claims")
plt.savefig("Previous Claims vs Premium Amount Scaled.png")

max(df_copy["Credit_Score"])

def get_credit_score(row):
    """
    Determines a random credit score based on the insurance amount.
    """
    insurance_amount = row['Premium_Amount']
    credit_score=0
    if 0 <= insurance_amount < 1000:
      credit_score=np.random.randint(700, 853)

    elif 1000 <= insurance_amount < 2000:
      credit_score=np.random.randint(600, 700)

    elif 2000 <= insurance_amount < 3000:
      credit_score=np.random.randint(500, 600)

    elif 3000 <= insurance_amount <= 5400:
      credit_score=np.random.randint(300, 500)
    return credit_score
df_copy['Credit_Score'] = df_copy.apply(get_credit_score, axis=1)
    #if np.random.rand() < 0.005:
    #  noise = np.random.uniform(-100,100)
    #  credit_score+=noise
    #  return ((credit_score-300)/524)*524+300

plt.scatter(df_copy[target_col],df_copy["Credit_Score"])

max(df['Health_Score'])

import pandas as pd
def get_health_score(row):
  """
  Determines a random health score based on the insurance amount.
  """
  insurance_amount = row['Premium_Amount']
  if 0 <= insurance_amount < 1000:  # Lower insurance amount
      amt=np.random.randint(45, 59)  # High health score range
      if np.random.rand() < 0.005:
        noise = np.random.uniform(-3,0)
        return   amt+noise# Lower-moderate health score range
      return amt

  elif 1000 <= insurance_amount < 2000:
      amt=np.random.randint(30, 45)  # Moderate health score range
      if np.random.rand() < 0.005:
        noise = np.random.uniform(-3,3)
        return   amt+noise# Lower-moderate health score range
      return amt

  elif 2000 <= insurance_amount < 3000:
    amt=np.random.randint(15, 30)
    if np.random.rand() < 0.005:
      noise = np.random.uniform(-3,3)
      return   amt+noise# Lower-moderate health score range
    return amt

  elif 3000 <= insurance_amount <= 5400:
    amt=np.random.randint(0, 15)
    if np.random.rand() < 0.005:
      noise = np.random.uniform(0,3)
      return amt+noise
    return amt   #Low health score range
df_copy['Health_Score'] = df_copy.apply(get_health_score,axis=1)

plt.scatter(df_copy[target_col],df_copy["Health_Score"])

min(df_copy['Age'])

def age_score(row):
  insurance_amount=row['Premium_Amount']
  if 4000 <= insurance_amount < 5400:
    return np.random.randint(50, 65)
  elif 0 <= insurance_amount < 2000:
    return np.random.randint(26, 40)
  elif 2000 <= insurance_amount < 3000:
    return np.random.randint(41,50)
  elif 3000 <= insurance_amount <4000:
    return np.random.randint(18, 25)
df_copy['Age'] = df_copy.apply(age_score,axis=1)

plt.scatter(df_copy[target_col],df_copy["Age"])

features_final=['Annual_Income','Age','Credit_Score','Health_Score','Previous_Claims']
target_col='Premium_Amount'
for col in features_final:
  plt.scatter(df_copy[target_col],df_copy[col])
  plt.title(f'{col} vs {target_col}')
  plt.show()

"""## Model Building

#X and y
"""

X=df_copy[features_final]
y = df_copy[target_col]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42)

X.describe()

#Defining list for rmse and r^2 score to visualize matrix
rmse_list=[]
rmse_list.append(850)
mae_list=[]
r2_score_list=[]
r2_score_list.append("NA")
mae_list.append("NA")
model_list=["Kaggle Competition","Linear Regresion","Lasso","XG Boost","Decision Tree Regressor","CatBoost"]

"""## Linear Regression"""

from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, mean_absolute_error
lr_model = LinearRegression()
lr_model.fit(X_train, y_train)


y_pred = lr_model.predict(X_test)

mse = mean_squared_error(y_test, y_pred) #Calculate MSE [2][5]
mae = mean_absolute_error(y_test, y_pred) #Calculate MAE [2][5]
lr_rmse = np.sqrt(mse) #Calculate RMSE [2]
lr_r2_score=r2_score(y_test, y_pred)



print("Mean Squared Error (MSE):", mse) #Prints MSE
print("Mean Absolute Error (MAE):", mae) #Prints MAE [2]
print("Root Mean Squared Error (RMSE):", lr_rmse) # Prints RMSE
print("R-squared (R^2):", lr_r2_score)

print("Coefficients:", lr_model.coef_)  #Prints the coefficient [2]
print("Intercept:", lr_model.intercept_)
rmse_list.append(lr_rmse)
r2_score_list.append(lr_r2_score)
mae_list.append(mae)
with open("linear_regression_model.pkl", 'wb') as file: #wb for write binary [1][2]
    pickle.dump(lr_model, file)

"""## Lasso Regression"""

from sklearn.linear_model import Lasso
lasso = Lasso(alpha=0.2)
lasso.fit(X_train, y_train)

# 4. Make predictions on the test set
y_pred = lasso.predict(X_test)

# 5. Calculate metrics
mse = mean_squared_error(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
lasso_rmse = np.sqrt(mse)
lasso_r2_score=r2_score(y_test, y_pred)

# 6. Print the metrics
print("Mean Squared Error (MSE):", mse)
print("Mean Absolute Error (MAE):", mae)
print("Root Mean Squared Error (RMSE):", lasso_rmse)
print("R-squared (R^2):", lasso_r2_score)
mae_list.append(mae)
rmse_list.append(lasso_rmse)
r2_score_list.append(lasso_r2_score)
with open("lasso_regression_model.pkl", 'wb') as file: #wb for write binary [1][2]
    pickle.dump(lasso, file)

"""## XG Boost"""

import xgboost as xgb
xg_reg = xgb.XGBRegressor(objective='reg:squarederror', #Objective is a required parameter [1]
                               n_estimators=100, #Number of boosting iterations [1]
                               random_state=42) # for reproducibility

xg_reg.fit(X_train, y_train) #Fit the model [1]

# 4. Make predictions on the test set [1]
y_pred = xg_reg.predict(X_test)

# 5. Calculate metrics [1][2]
mse = mean_squared_error(y_test, y_pred) #Calculate MSE [1]
mae = mean_absolute_error(y_test, y_pred) #Calculate MAE [1]
xg_reg_rmse = np.sqrt(mse) #Calculate RMSE [1]
xg_r2_score=r2_score(y_test, y_pred)

# 6. Print the metrics [1]
print("Mean Squared Error (MSE):", mse) #Prints MSE [1]
print("Mean Absolute Error (MAE):", mae) #Prints MAE [1]
print("Root Mean Squared Error (RMSE):", xg_reg_rmse) #Prints RMSE [1]
print("R-squared (R^2):", xg_r2_score)
rmse_list.append(xg_reg_rmse)
r2_score_list.append(xg_r2_score)
mae_list.append(mae)
with open("xg_regression_model.pkl", 'wb') as file: #wb for write binary [1][2]
    pickle.dump(xg_reg, file)

"""## Decision Tree Regressor"""

from sklearn.tree import DecisionTreeRegressor
dt_reg = DecisionTreeRegressor(random_state=42, criterion="friedman_mse") # other options are ‘mae’ and ‘poisson’ [1]
dt_reg.fit(X_train, y_train)

# 4. Make predictions on the test set [1]
y_pred = dt_reg.predict(X_test)

# 5. Calculate metrics [1]
mse = mean_squared_error(y_test, y_pred) #Calclate MSE [1][3]
mae = mean_absolute_error(y_test, y_pred) #Calculate MAE [1][3]
dt_reg_rmse = np.sqrt(mse) #Calculate RMSE [1][3]
dt_reg_r2_score=r2_score(y_test, y_pred)

# 6. Print the metrics [1]
print("Mean Squared Error (MSE):", mse) #Print MSE [1]
print("Mean Absolute Error (MAE):", mae) #Print MAE [1]
print("Root Mean Squared Error (RMSE):", dt_reg_rmse)
print("R-squared (R^2):", dt_reg_r2_score)
rmse_list.append(dt_reg_rmse)
r2_score_list.append(dt_reg_r2_score)
mae_list.append(mae)
with open("decision_tree__regression_model.pkl", 'wb') as file: #wb for write binary [1][2]
    pickle.dump(dt_reg, file)

"""## CatBoost"""

#Prerequisite
!pip install catboost

from catboost import CatBoostRegressor

cat_model = CatBoostRegressor(iterations=500, #Number of boosting iterations
                               depth=10, #Depth of the tree
                               learning_rate=0.05, #Learning rate
                               loss_function='RMSE', #Loss function [1]
                               random_seed=42, #Random seed for reproducibility
                               logging_level='Silent') # Suppress verbose output [1]

cat_model.fit(X_train, y_train)

# 4. Make predictions on the test set
y_pred = cat_model.predict(X_test)

# 5. Calculate metrics
mse = mean_squared_error(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
cat_rmse = np.sqrt(mse)
cat_r2_score=r2_score(y_test, y_pred)

# 6. Print the metrics
print("Mean Squared Error (MSE):", mse)
print("Mean Absolute Error (MAE):", mae)
print("Root Mean Squared Error (RMSE):", cat_rmse)
print("R-squared (R^2):", cat_r2_score)
rmse_list.append(cat_rmse)
r2_score_list.append(cat_r2_score)
mae_list.append(mae)
with open("catboost__regression_model.pkl", 'wb') as file: #wb for write binary [1][2]
    pickle.dump(cat_model, file)

"""## Ploting Results"""

plt.figure(figsize=(10, 6))  # Create a figure and axes [1]
plt.plot(model_list, rmse_list, marker='o', linestyle='-')  # Create the line plot [1]
plt.xlabel("Model Name")  # Set the x-axis label [1]
plt.ylabel("RMSE")  # Set the y-axis label [1]
plt.title("Model Comparison - RMSE (Line Plot)")  # Set the title [1]
plt.xticks(rotation=45, ha="right")  # Rotate x-axis labels for better readability [1]
plt.grid(True)  # Add grid lines [1]
plt.tight_layout()  # Adjust the plot to fit the labels [1]
plt.show()  # Show the plot [1]
plt.savefig("RMSE Model Comparsion")

plt.figure(figsize=(10, 6))  # Create a figure and axes [1]
plt.plot(model_list, r2_score_list, marker='o', linestyle='-')  # Create the line plot [1]
plt.xlabel("Model Name")  # Set the x-axis label [1]
plt.ylabel("R^2")  # Set the y-axis label [1]
plt.title("Model Comparison - R^2 (Line Plot)")  # Set the title [1]
plt.xticks(rotation=45, ha="right")  # Rotate x-axis labels for better readability [1]
plt.grid(True)  # Add grid lines [1]
plt.tight_layout()  # Adjust the plot to fit the labels [1]
plt.show()  # Show the plot [1]
plt.savefig("R^2 Model Comparsion")

plt.figure(figsize=(10, 6))  # Create a figure and axes [1]
plt.plot(model_list, mae_list, marker='o', linestyle='-')  # Create the line plot [1]
plt.xlabel("Model Name")  # Set the x-axis label [1]
plt.ylabel("MAE")  # Set the y-axis label [1]
plt.title("Model Comparison - MAE (Line Plot)")  # Set the title [1]
plt.xticks(rotation=45, ha="right")  # Rotate x-axis labels for better readability [1]
plt.grid(True)  # Add grid lines [1]
plt.tight_layout()  # Adjust the plot to fit the labels [1]
plt.show()  # Show the plot [1]
plt.savefig("MAE Model Comparsion")

